// Generated by gencpp from file piccolo_ros/PiccoloWaypoint.msg
// DO NOT EDIT!


#ifndef PICCOLO_ROS_MESSAGE_PICCOLOWAYPOINT_H
#define PICCOLO_ROS_MESSAGE_PICCOLOWAYPOINT_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace piccolo_ros
{
template <class ContainerAllocator>
struct PiccoloWaypoint_
{
  typedef PiccoloWaypoint_<ContainerAllocator> Type;

  PiccoloWaypoint_()
    : header()
    , vehicleid(0)
    , latitude(0.0)
    , longitude(0.0)
    , deployParachute(false)
    , deployDrop(false)
    , orbitDirection(false)
    , cameraTarget(false)
    , landingPoint(false)
    , slopeControl(false)
    , lightsOn(false)
    , preTurn(false)
    , orbitRadius(0)
    , altitude(0.0)
    , windFind(0)
    , orbitTime(0)
    , index(0)
    , next(0)
    , user(0)
    , orbitAbove(false)
    , orbitBelow(false)
    , hoverPoint(false)
    , altitudeToGround(false)
    , orbitMultiplier50(false)
    , altLSB(0)  {
    }
  PiccoloWaypoint_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , vehicleid(0)
    , latitude(0.0)
    , longitude(0.0)
    , deployParachute(false)
    , deployDrop(false)
    , orbitDirection(false)
    , cameraTarget(false)
    , landingPoint(false)
    , slopeControl(false)
    , lightsOn(false)
    , preTurn(false)
    , orbitRadius(0)
    , altitude(0.0)
    , windFind(0)
    , orbitTime(0)
    , index(0)
    , next(0)
    , user(0)
    , orbitAbove(false)
    , orbitBelow(false)
    , hoverPoint(false)
    , altitudeToGround(false)
    , orbitMultiplier50(false)
    , altLSB(0)  {
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint16_t _vehicleid_type;
  _vehicleid_type vehicleid;

   typedef float _latitude_type;
  _latitude_type latitude;

   typedef float _longitude_type;
  _longitude_type longitude;

   typedef uint8_t _deployParachute_type;
  _deployParachute_type deployParachute;

   typedef uint8_t _deployDrop_type;
  _deployDrop_type deployDrop;

   typedef uint8_t _orbitDirection_type;
  _orbitDirection_type orbitDirection;

   typedef uint8_t _cameraTarget_type;
  _cameraTarget_type cameraTarget;

   typedef uint8_t _landingPoint_type;
  _landingPoint_type landingPoint;

   typedef uint8_t _slopeControl_type;
  _slopeControl_type slopeControl;

   typedef uint8_t _lightsOn_type;
  _lightsOn_type lightsOn;

   typedef uint8_t _preTurn_type;
  _preTurn_type preTurn;

   typedef uint8_t _orbitRadius_type;
  _orbitRadius_type orbitRadius;

   typedef float _altitude_type;
  _altitude_type altitude;

   typedef uint8_t _windFind_type;
  _windFind_type windFind;

   typedef uint8_t _orbitTime_type;
  _orbitTime_type orbitTime;

   typedef uint8_t _index_type;
  _index_type index;

   typedef uint8_t _next_type;
  _next_type next;

   typedef uint8_t _user_type;
  _user_type user;

   typedef uint8_t _orbitAbove_type;
  _orbitAbove_type orbitAbove;

   typedef uint8_t _orbitBelow_type;
  _orbitBelow_type orbitBelow;

   typedef uint8_t _hoverPoint_type;
  _hoverPoint_type hoverPoint;

   typedef uint8_t _altitudeToGround_type;
  _altitudeToGround_type altitudeToGround;

   typedef uint8_t _orbitMultiplier50_type;
  _orbitMultiplier50_type orbitMultiplier50;

   typedef uint8_t _altLSB_type;
  _altLSB_type altLSB;




  typedef boost::shared_ptr< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> const> ConstPtr;

}; // struct PiccoloWaypoint_

typedef ::piccolo_ros::PiccoloWaypoint_<std::allocator<void> > PiccoloWaypoint;

typedef boost::shared_ptr< ::piccolo_ros::PiccoloWaypoint > PiccoloWaypointPtr;
typedef boost::shared_ptr< ::piccolo_ros::PiccoloWaypoint const> PiccoloWaypointConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace piccolo_ros

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'piccolo_ros': ['/home/eloi/bigactorrte/ros_workspace/src/piccolo_ros/msg'], 'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
{
  static const char* value()
  {
    return "94cf365c5d73022abc5ccff9d924c6bf";
  }

  static const char* value(const ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x94cf365c5d73022aULL;
  static const uint64_t static_value2 = 0xbc5ccff9d924c6bfULL;
};

template<class ContainerAllocator>
struct DataType< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
{
  static const char* value()
  {
    return "piccolo_ros/PiccoloWaypoint";
  }

  static const char* value(const ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
uint16 vehicleid\n\
float32 latitude\n\
float32 longitude\n\
bool deployParachute\n\
bool deployDrop\n\
bool orbitDirection\n\
bool cameraTarget\n\
bool landingPoint\n\
bool slopeControl\n\
bool lightsOn\n\
bool preTurn\n\
uint8 orbitRadius\n\
float32 altitude\n\
uint8 windFind\n\
uint8 orbitTime\n\
uint8 index\n\
uint8 next\n\
uint8 user\n\
bool orbitAbove\n\
bool orbitBelow\n\
bool hoverPoint\n\
bool altitudeToGround\n\
bool orbitMultiplier50\n\
uint8 altLSB\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.vehicleid);
      stream.next(m.latitude);
      stream.next(m.longitude);
      stream.next(m.deployParachute);
      stream.next(m.deployDrop);
      stream.next(m.orbitDirection);
      stream.next(m.cameraTarget);
      stream.next(m.landingPoint);
      stream.next(m.slopeControl);
      stream.next(m.lightsOn);
      stream.next(m.preTurn);
      stream.next(m.orbitRadius);
      stream.next(m.altitude);
      stream.next(m.windFind);
      stream.next(m.orbitTime);
      stream.next(m.index);
      stream.next(m.next);
      stream.next(m.user);
      stream.next(m.orbitAbove);
      stream.next(m.orbitBelow);
      stream.next(m.hoverPoint);
      stream.next(m.altitudeToGround);
      stream.next(m.orbitMultiplier50);
      stream.next(m.altLSB);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct PiccoloWaypoint_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::piccolo_ros::PiccoloWaypoint_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "vehicleid: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.vehicleid);
    s << indent << "latitude: ";
    Printer<float>::stream(s, indent + "  ", v.latitude);
    s << indent << "longitude: ";
    Printer<float>::stream(s, indent + "  ", v.longitude);
    s << indent << "deployParachute: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.deployParachute);
    s << indent << "deployDrop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.deployDrop);
    s << indent << "orbitDirection: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitDirection);
    s << indent << "cameraTarget: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cameraTarget);
    s << indent << "landingPoint: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.landingPoint);
    s << indent << "slopeControl: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.slopeControl);
    s << indent << "lightsOn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lightsOn);
    s << indent << "preTurn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.preTurn);
    s << indent << "orbitRadius: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitRadius);
    s << indent << "altitude: ";
    Printer<float>::stream(s, indent + "  ", v.altitude);
    s << indent << "windFind: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.windFind);
    s << indent << "orbitTime: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitTime);
    s << indent << "index: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.index);
    s << indent << "next: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.next);
    s << indent << "user: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.user);
    s << indent << "orbitAbove: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitAbove);
    s << indent << "orbitBelow: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitBelow);
    s << indent << "hoverPoint: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.hoverPoint);
    s << indent << "altitudeToGround: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.altitudeToGround);
    s << indent << "orbitMultiplier50: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.orbitMultiplier50);
    s << indent << "altLSB: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.altLSB);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PICCOLO_ROS_MESSAGE_PICCOLOWAYPOINT_H
